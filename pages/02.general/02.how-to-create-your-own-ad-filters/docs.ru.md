---
title: 'Как составлять свои фильтры'
taxonomy:
    category:
        - docs
visible: true
---

* [Введение](#introduction)
* [Комментарии](#comments)
* [Базовые правила](#basic-rules)
    * [Синтаксис базовых правил](#basic-rules-syntax)
    * [Специальные символы](#basic-rules-special-characters)
    * [Поддержка регулярных выражений](#regexp-support)
    * [Примеры базовых правил](#basic-rules-examples)
    * [Модификаторы](#basic-rules-modifiers)
        * [Базовые модификаторы](#basic-rules-common-modifiers)
            * [$domain](#domain-modifier)
            * [$third-party](#third-party-modifier)
            * [$popup](#popup-modifier)
            * [$match-case](#match-case-modifier)
        * [Ограничение по типу контента](#content-type-modifiers)
            * [Примеры ограничений](#content-type-modifiers-examples)
            * [$image](#image-modifier)
            * [$stylesheet](#stylesheet-modifier)
            * [$script](#script-modifier)
            * [$object](#object-modifier)
            * [$object-subrequest](#object-subrequest-modifier)
            * [$font](#font-modifier)
            * [$media](#media-modifier)
            * [$subdocument](#subdocument-modifier)
            * [$xmlhttrequest](#xmlhttprequest-modifier)
            * [$other](#other-modifier)
        * [Модификаторы правил-исключений](#exceptions-modifiers)
            * [$elemhide](#elemhide-modifier)
            * [$content](#content-modifier)
            * [$jsinject](#jsinject-modifier)
            * [$urlblock](#urlblock-modifier)
            * [$document](#document-modifier)
            * [$stealth](#stealth-modifier)
            * [Generic правила](#generic-rules)
                * [$generichide](#generichide-modifier)
                * [$genericblock](#genericblock-modifier)
    * [Расширенные возможности](#advanced-modifiers)
        * [$empty](#empty-modifier)
        * [$mp4](#mp4-modifier)
        * [$replace](#replace-modifier)
* [Косметические правила](#cosmetic-rules)
    * [Правила скрытия элементов](#cosmetic-elemhide-rules)
        * [Синтаксис правил скрытия](#elemhide-syntax)
        * [Примеры правил скрытия](#elemhide-examples)
        * [Исключения для правил скрытия](#elemhide-exceptions)
    * [Правила CSS стилей](#cosmetic-css-rules)
        * [Синтаксис правил CSS стилей](#cosmetic-css-rules-syntax)
        * [Примеры правил CSS стилей](#cosmetic-css-rules-examples)
        * [Исключения для правил CSS стилей](#cosmetic-css-rules-exceptions)
    * [Расширенные CSS селекторы](#extended-css-selectors)
        * [Псевдо-класс :has()](#extended-css-has)
        * [Псевдо-класс :contains()](#extended-css-contains)
        * [Псевдо-класс :matches-css()](#extended-css-matches-css)
* [Правила фильтрации HTML](#html-filtering-rules)
    * [Синтаксис правил фильтрации HTML](#html-filtering-rules-syntax)
    * [Примеры правил фильтрации HTML](#html-filtering-rules-examples)
    * [Специальные атрибуты](#html-filtering-rules-attributes)
        * [tag-content](#tag-content-attribute)
        * [wildcard](#wildcard-attribute)
        * [max-length](#max-length-attribute)
        * [min-length](#min-length-attribute)
        * [parent-elements](#parent-elements-attribute)
        * [parent-search-level](#parent-search-level-attribute)
    * [Исключения для правил фильтрации HTML](#html-filtering-rules-exceptions)
* [Javascript правила](#javascript-rules)
    * [Синтаксис javascript правил](#javascript-rules-syntax)
    * [Примеры javascript правил](#javascript-rules-examples)
    * [Исключения для javascript правил](#javascript-rules-exceptions)
* [Удачи в составлении своих фильтров!](#good-luck)

<a id="introduction"></a>
## Введение

Фильтр — это набор правил фильтрации рекламного контента (баннеров, всплывающих окон и тому подобного). Вместе с Adguard поставляется набор стандартных фильтров, создаваемых нами. Они постоянно дорабатываются и дополняются, и, как мы надеемся, удовлетворяют требованиям большинства пользователей.

Вместе с тем, Adguard позволяет создать ваш собственный пользовательский фильтр, используя те же самые правила, которые используем мы в наших фильтрах.

Для описания синтаксиса правил мы используем [Augmented BNF for Syntax Specifications](https://tools.ietf.org/html/rfc5234), но мы не всегда строго следуем этой спецификации.

> Синтаксис правил Adguard изначально основан на синтаксисе правил Adblock Plus, но расширяет его, добавляя новые типы правил для улучшения фильтрации. Часть информации в этой статье об общих для ABP и Adguard типах правил взята из [этой статьи](http://adblockplus.org/ru/filters).

<a id="comments"></a>
## Комментарии

Любое правило, начинающееся с восклицательного знака, содержит комментарий. Оно отображается в списке правил серым цветом. Adguard будет игнорировать это правило, так что можете спокойно писать там всё, что хотите. Вы можете, например, расположить комментарий выше реального правила, чтобы описать для чего оно нужно.

Например:
```
! Это текст комментария. Под ним, для сравнения, текст реального правила фильтрации.
||example.org^
```

<a id="basic-rules"></a>
## Базовые правила

Так называемые _"Базовые правила"_ — самый простой вид правил. Эти правила предназначены для блокировки запросов на определенный адрес. Либо, при наличии специального маркера `@@` в начале правила, для разблокировки запроса. Основной принцип для этого типа правил достаточно прост: необходимо указать адрес и дополнительные параметры, которые ограничивают или расширяют область действия правила.

> #### Подзапросы
> Базовые правила, блокирующие запросы, применяются **только к подзапросам**. То есть, они не будут блокировать загрузку страницы в браузере.

> #### Статус ответа
> Браузер определяет заблокированный подзапрос как выполненный с ошибкой.

<a id="basic-rules-syntax"></a>
### Синтаксис базовых правил

```
      rule = ["@@"] pattern [ "$" modifiers ]
 modifiers = [modifier0, modifier1[, ...[, modifierN]]]
```

* **`pattern`** — маска адреса. URL каждого запроса сопоставляется с этой маской. В шаблоне вы можете использовать некоторые специальные символы, описание которых будет дано [ниже](#basic-rules-special-characters).
* **`@@`** — маркер, который используется для обозначения правил-исключений. С такого маркера должны начинаться правила, отключающие фильтрацию для запроса.
* **`modifiers`** — параметры, используемые для "уточнения" базового правила. Некоторые параметры ограничивают область действия правила, а некоторые могут полностью изменить принцип его работы.

<a id="basic-rules-special-characters"></a>
### Специальные символы

* **`*`** — wildcard-символ. Символ, обозначающий "произвольный набор символов". Это может быть как пустая строка, так и строка любой длины.
* **`||`** — соответствие началу адреса. Этот специальный символ позволяет не указывать конкретный протокол и поддомен в маске адреса. То есть, `||` соответствует сразу `http://*.`, `https://*.`, `ws://*.`, `wss://*.`.
* **`^`** — указатель для разделительного символа. Разделителем может быть любой символ кроме буквы, цифры и следующих символов: `_` `-` `.` `%`. Например, в адресе `http:`**`//`**`example.com`**`/?`**`t=1`**`&`**`t2=t3` жирным выделены разделительные символы.
* **`|`** — указатель на начало или конец адреса. Значение зависит от того, находится этот символ в начале или конце маски. Например, правило `swf|` соответствует `http://example.com/annoyingflash.swf` , но не `http://example.com/swf/index.html`. `|http://example.org` соответствует `http://example.org`, но не `http://domain.com?url=http://example.org`.

> #### Визуальное представление
> Советуем ознакомиться с [этой статьей](https://adblockplus.org/filter-cheatsheet#blocking), чтобы лучше понять, как должны строиться такие правила.

<a id="regexp-support"></a>
### Поддержка регулярных выражений

Если вы хотите добиться еще большей гибкости при составлении правил, вы можете использовать [регулярные выражения](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Regular_Expressions) вместо упрощенной маски со специальными символами, которая используется по умолчанию. 

> #### Производительность
> Такие правила работают медленнее обычных, поэтому рекомендуется избегать их, или хотя бы ограничивать их область действия конкретными доменами.

Чтобы блокировщик определил, что вы хотите использовать регулярное выражение, необходимо, чтобы `pattern` имел особый вид:
```
pattern = "/" regexp "/"
```

Например, правило `/banner\d+/$third-party` применит регулярное выражение `banner\d+` ко всем сторонним запросам. Правила-исключения с использованием регулярных выражений выглядят вот так: `@@/banner\d+/`.

> #### Совместимость
> Браузерные расширения Adguard для Safari и Adguard для iOS не полностью поддерживают регулярные выражения в силу [ограничений Content Blocking API](https://webkit.org/blog/3476/content-blockers-first-look/) (в статье по ссылке найдите раздел "The Regular expression format").

<a id="basic-rules-examples"></a>
### Примеры базовых правил

* `||example.com/ads/*` — простое правило, которое соотвествует адресам типа `http://example.com/ads/banner.jpg` и даже `http://subdomain.example.com/ads/otherbanner.jpg`.

* `||example.org^$third-party` — правило, которое блокирует сторонние запросы к домену `example.org` и его поддоменам.

* `@@||example.com$document` — наиболее общее правило-исключение. Такое правило полностью отключает фильтрацию на домене `example.com` и всех его поддоменах. Существует ряд параметров, которые также можно использовать в правилах-исключениях. Более подробно о правилах-исключениях и параметрах, которые могут в таких правилах использоваться, написано [ниже](#exceptions-modifiers).

<a id="basic-rules-modifiers"></a>
### Модификаторы

> #### Обратите внимание
> Возможности, описанные в этом разделе, обычно используются опытными пользователями. Они расширяют возможности «Общих правил», но для их применения необходимо иметь начальное представление о работе браузера.

Вы можете изменить поведение «общего правила», используя дополнительные модификаторы. Список этих параметров располагается в конце правила за знаком доллара `$` и разделяется запятыми.

Пример использования модификаторов:
```
||domain.com$popup,third-party
```

> #### Визуальное представление
> Советуем ознакомиться с [этой статьей](https://adblockplus.org/filter-cheatsheet#options), чтобы лучше понять, как должны применяться модификаторы.

<a id="basic-rules-common-modifiers"></a>
#### Базовые модификаторы

Приведенные ниже модификаторы являются наиболее простыми для понимания и часто применяемыми.

<a id="domain-modifier"></a>
##### **`domain`**

Модификатор `domain` ограничивает область действия правила списком доменов (и их поддоменов). Для того чтобы указать несколько доменов в одном правиле, нужно использовать символ `|` в качестве разделителя.

###### Примеры `domain`

* `||baddomain.com^$domain=example.org` — правило для блокировки запросов, которые соответствуют указанной маске, и отправленных с домена или поддомена `example.org`.
* `||baddomain.com^$domain=example.org|example.com` — такое же правило, но срабатывать оно будет как для домена `example.org`, так и для `example.com`.

Чтобы правило не применялось на определенных доменах, перед доменным именем необходимо добавить символ `~`.

###### Примеры `domain` и `~`

* `||baddomain.com^$domain=~example.org` — правило для блокировки запросов, которые соответствуют указанной маске, и отправленных с любого домена, кроме `example.org` и его поддоменов.
* `||baddomain.com^$domain=example.org|~foo.example.org` — в данном примере правило будет соответствовать запросам, отправленным с домена `example.org` и всех его поддоменов, кроме поддомена `foo.example.org`.

<a id="third-party-modifier"></a>
##### **`third-party`**

Ограничение на сторонние или собственные запросы. Сторонним является запрос, отправленный с другого сайта. Например, запрос к домену `example.org`, отправленный с домена `domain.com`, является сторонним. 

> #### Поддомены
> Обратите внимание, что запрос, отправленный на поддомен того же домена (или наоборот), сторонним не является. Например, запрос к `subdomain.example.org`, отправленный с домена `example.org`, не является сторонним.

Если указан модификатор `third-party`, то правило применяется только к сторонним запросам.

###### Примеры `third-party`

* `||domain.com$third-party` — правило применяется на всех сайтах, кроме `domain.com` и его поддоменов. Пример стороннего запроса: `http://example.org/banner.jpg`.

Если указан модификатор `~third-party`, то правило применяется только к запросам, которые не являются сторонними. То есть, эти запросы отправлены с того же домена.

###### Примеры `~third-party`

* `||domain.com$~third-party` — такое правило уже будет применяться только на самом `domain.com`, но не на других сайтах. Пример запроса, который не является сторонним: `http://domain.com/icon.ico`.

<a id="popup-modifier"></a>
##### **`popup`**

Adguard будет пытаться закрыть браузерную вкладку с любым адресом, подходящим под правило с этим модификатором. Обратите внимание, что закрыть можно не любую вкладку.

###### Примеры `popup`

* `||domain.com*^$popup` — при попытке перехода на сайт `http://domain.com` с любой страницы в браузере, новая вкладка, в которой должен открыться указанный сайт, будет закрыта.

<a id="match-case-modifier"></a>
##### **`match-case`**

Определяет правило, которое применяется только к адресам с совпадением регистра символов. По умолчанию регистр символов не учитывается.

###### Примеры `match-case`

* `*/BannerAd.gif$match-case` — такоe правило будет блокировать `http://example.com/BannerAd.gif`, но не `http://example.com/bannerad.gif`.

<a id="content-type-modifiers"></a>
#### Ограничение по типу контента

Существует целый набор модификаторов, которые ограничивают действие правила только запросами к ресурсам определенного типа. Эти модификаторы можно комбинировать, например распространить правило одновременно на картинки и скрипты.

> #### Совместимость с разными версиями Adguard
> Обратите внимание, что существует большая разница в том, как разные версии Adguard определяют тип контента. В случае браузерных расширений тип контента для каждого запроса предоставляется самим браузером. В случае Adguard для Windows, macOS и Android для определения используется следующая методика: вначале мы пытаемся определить тип запроса по расширению загружаемого файла. Если запрос не заблокирован на этом этапе, то тип запроса уточняется с использованием заголовка `Content-Type` в начале ответа, полученного от сервера.

<a id="content-type-modifiers-examples"></a>
##### Примеры ограничений

* `||example.org^$image` — соответствует всем картинкам с домена `example.org`.
* `||example.org^$script,stylesheet` — соответствует всем скриптам и стилям с домена `example.org`.
* `||example.org^$~image,~script,~stylesheet` — соответствует всем запросам к домену `example.org` кроме картинок, скриптов и стилей.

<a id="image-modifier"></a>
##### **`image`**

Правило будет соответствовать запросам к изображениям.

<a id="stylesheet-modifier"></a>
##### **`stylesheet`**

Правило будет соответствовать запросам к файлам CSS стилей.

<a id="script-modifier"></a>
##### **`script`**

Правило будет соответствовать запросам к файлам скриптов (например javascript, vbscript).

<a id="object-modifier"></a>
##### **`object`**

Правило применяется к ресурсам, управляемым браузерными плагинами (например, Java или Flash).

<a id="object-subrequest-modifier"></a>
##### **`object-subrequest`**

Запросы, инициированные плагинами (чаще всего это Flash).

> #### Совместимость с разными версиями Adguard
> Adguard для Windows, macOS и Android часто не может корректно определить этот тип, и определяет его как `other`.

<a id="font-modifier"></a>
##### **`font`**

Правило будет соответствовать запросам к файлам шрифтов (например, файлам с расширением .woff).

<a id="media-modifier"></a>
##### **`media`**

Правило будет соответствовать запросам к медиа-файлам (музыка и видео, например, файлы с расширением .mp4).

<a id="subdocument-modifier"></a>
##### **`subdocument`**

Правило будет соответствовать запросам к встроенным страницам (HTML-теги `frame` и `iframe`).

<a id="xmlhttprequest-modifier"></a>
##### **`xmlhttprequest`**

Правило применяется только к ajax-запросам. То есть к запросам, отправленным с помощью javascript-объекта `XMLHttpRequest`.

> #### Совместимость с разными версиями Adguard
> Adguard для Windows, macOS и Android не всегда может корректно определить этот тип контента, и определяет его как `other` или `script`.

<a id="other-modifier"></a>
##### **`other`**

Правило применяется к запросам, для которых не был определен ни один из перечисленных выше типов.

<a id="exceptions-modifiers"></a>
#### Модификаторы правил-исключений

Правила-исключения отключают действие других базовых правил для адресов, которым они соответствуют. Отличаются правила-исключения тем, что они начинаются со специального маркера `@@`. Для таких правил работают все базовые модификаторы, перечисленные выше. Также добавляется несколько специальных модификаторов, которые будут описаны ниже.

> #### Визуальное представление
> Советуем ознакомиться с [этой статьей](https://adblockplus.org/filter-cheatsheet#exceptions), чтобы лучше понять, как должны строиться правила-исключения.

<a id="elemhide-modifier"></a>
##### **`elemhide`**

Отключает косметические правила на страницах, подходящих под правило. О косметических правилах речь [пойдет ниже](#cosmetic-rules).

###### Примеры `elemhide`

* `@@||example.com^$elemhide` — отменяет все косметические правила для страниц на сайте `example.com` и всех его поддоменов.

<a id="content-modifier"></a>
##### **`content`**

Отключает правила фильтрации HTML-элементов на страницах, подходящих под правило. О правилах фильтрации HTML-элементов речь [пойдет ниже](#html-filtering-rules).

###### Примеры `content`

* `@@||example.com^$content` — отменяет все правила фильтрации HTML-элементов для страниц на сайте `example.com` и всех его поддоменов.

<a id="jsinject-modifier"></a>
##### **`jsinject`**

Запрещает добавление javascript-кода на страницу. О javascript правилах речь пойдет ниже.

###### Примеры `jsinject`

* `@@||example.com^$jsinject` — отменяет все javascript правила для страниц на сайте `example.com` и всех его поддоменов.

<a id="urlblock-modifier"></a>
##### **`urlblock`**

Отключает блокировку всех запросов, отправленных со страниц, подходящих под это правило.

###### Примеры `urlblock`

* `@@||example.com^$urlblock` — запросы, отправленные со страниц на сайте `example.com` и всех его поддоменов, не будет блокироваться.

<a id="document-modifier"></a>
##### **`document`**

Полностью отключает блокировку на страницах, подходящих под это правило. Эквивалентно одновременному использованию модификаторов `elemhide`, `content`, `urlblock` и `jsinject`.

###### Примеры `document`

* `@@||example.com^$document` — полностью отключает блокировку для всех страниц на домене `example.com` и всех его поддоменах.

<a id="stealth-modifier"></a>
##### **`stealth`**

Отключает модуль "Антитрекинг" для всех страниц и запросов, подходящих под это правило.

> #### Совместимость с разными версиями Adguard
> Модуль "Антитрекинг" на данный момент доступен только в Adguard для Windows и macOS. В будущем мы планируем добавить его во все продукты Adguard. В продуктах без поддержки модуля "Антитрекинг" правила с этим модификатором игнорируются.

###### Примеры `stealth`

* `@@||example.com^$stealth` — полностью отключает модуль `Антитрекинг` для всех страниц на домене `example.com` и всех его поддоменах, а также для всех запросов и подзапросов.

<a id="generic-rules"></a>
##### Generic правила

Перед тем, как перейти к описанию следующих модификаторов, необходимо ввести определение _"generic правил"_. Правило является "generic", если его действие не ограничено конкретными доменами.

Например, следующие правила являются "generic":
```
###banner
~domain.com###banner
||domain.com^
||domain.com^$domain=~example.com
```

А вот такие правила уже не являются "generic":
```
domain.com###banner
||domain.com^$domain=example.com
```

<a id="generichide-modifier"></a>
###### **`generichide`**

Отключает все "generic" [косметические правила](#cosmetic-rules) на страницах, подходящих под правило-исключение.

* `@@||example.com^generichide` — отключает "generic" косметические правила на страницах сайта `example.com` и всех его поддоменах.

<a id="genericblock-modifier"></a>
###### **`genericblock`**

Отключает все generic базовые правила на страницах, подходящих под правило-исключение.

* `@@||example.com^$genericblock` — отключает "generic" базовые правила на страницах сайта `example.com` и всех его поддоменах.

<a id="advanced-modifiers"></a>
### Расширенные возможности

Модификаторы, описанные в этом разделе, полностью меняют поведение базовых правил, к которым эти модификаторы применены.

> #### Совместимость с разными версиями Adguard
> Модификаторы из этого раздела доступны только в Adguard для Windows, macOS и Android. Браузерные расширения ограничены возможностями, предоставляемыми браузерами, и некоторые функции им просто недоступны.

<a id="empty-modifier"></a>
##### **`empty`**

Обычно заблокированный запрос выглядит для браузера как ошибка сервера. В случае применения модификатора `empty`, Adguard эмулирует пустой ответ сервера со статусом `200 OK`.

###### Примеры `empty`

* `||example.org^$empty` — возвращает пустой ответ для всех запросов к домену `example.org` и всех его поддоменов.

<a id="mp4-modifier"></a>
##### **`mp4`**

В качестве ответа на заблокированный запрос Adguard возвращает короткое видео-заглушку.

###### Примеры `mp4`

* `||example.com/videos/$mp4` — блокирует загрузку видео с адресов `||example.com/videos/*` и заменяет ответ на видео-заглушку.

<a id="replace-modifier"></a>
##### **`replace`**

Этот модификатор полностью изменяет поведение правила. Если он применен, правило не будет блокировать запрос. Вместо этого содержимое ответа будет модифицировано в соответствии со значением модификатора.

> #### Обратите внимание
> Для использования этого модификатора требуется знание регулярных выражений.

###### Особенности `replace` правил

* `replace` правила применяются к любому текстовому ответу, но не будут применяться к бинарным (`media`, `image`, `object`, etc).
* `replace` правила не применяются если размер оригинального ответа больше 3МБ.
* Если к коду страницы применено `replace` правило, то другие правила (например, косметические) к коду страницы применены не будут.
* `replace` правила имеют более высокий приоритет, чем другие базовые правила (кроме исключений). То есть, если запрос соответствует двум правилам, и одно из них имеет модификатор `replace`, то именно это правило и будет применено.

###### Синтаксис `replace`

В целом, синтаксис `replace` напоминает то, как [работают в Perl](http://perldoc.perl.org/perlrequick.html#Search-and-replace) замены регулярными выражениями.

```
replace = "/" regex "/" replacement "/" modifiers
```

* `regex` — регулярное выражение.
* `replacement` — строка, которая будет использоваться для замены строки, соответствующей `regex`.
* `modifiers` — флаги регулярного выражения. Например, `i` - регистро-независимый поиск, или `s` - single-line режим.

В значении `replace` два символа должны быть экранированы: запятая (`,`) и (`$`). Для экранирования используется символ косой черты (`\`). Например, экранированная запятая: `\,`.

###### Примеры `replace`

```
://*.damoh.golem.de/$replace=/(<VAST(.|\s)*?>)(.|\s)*<\/VAST>/\$1<\/VAST>/i,domain=video.golem.de
```

В этом правиле можно выделить три части:

* Регулярное выражение: `(<VAST(.|\s)*?>)(.|\s)*<\/VAST>`
* Замена `\$1<\/VAST>` (обратите внимание, что символ `$` экранирован)
* Флаги регулярного выражения: `i` (регистро-независимый поиск)

Посмотрите, как работает это правило:
http://regexr.com/3cesk

<a id="cosmetic-rules"></a>
## Косметические правила

Принцип работы косметических правил понятен из их названия. В отличие от базовых правил, косметические предназначены не для блокирования рекламных запросов, а для обработки внешнего вида страниц. Например, они могут скрывать элементы страниц или даже преобразовывать общий стиль страниц.

> Для работы с косметическими правилами необходимы знания HTML и CSS. Так что если вы хотите научиться самостоятельно составлять такие правила, нужно получить хотя бы базовые навыки владения этими технологиями. Рекомендуем ознакомиться с [этой документацией](https://developer.mozilla.org/ru/docs/Web/Guide/CSS/Getting_started/What_is_CSS).

<a id="cosmetic-elemhide-rules"></a>
### Правила скрытия элемeнтов

Правила скрытия элементов предназначены, как это следует из их названия, для скрытия элементов веб-страниц. По сути это аналогично применению стиля `{ display: none; }` к выбранному элементу. 

<a id="elemhide-syntax"></a>
#### Синтаксис правил скрытия

```
   rule = [domains] "##" selector
domains = [domain0, domain1[, ...[, domainN]]]
```

* **`selector`** — [CSS селектор](https://developer.mozilla.org/ru/docs/Web/Guide/CSS/Getting_Started/Selectors), задающий элементы, которые должны быть скрыты.
* **`domains`** — ограничение на домены, на страницах которых будет применено правило.

Если вы хотите ограничить область действия одним или более доменами, просто перечислите их через запятую. Например: `example.org,example.com##selector`.

> Обратите внимание, что это правило будет работать также на всех поддоменах `example.org` и `example.com`.

Если вы хотите запретить действие правила на определенном домене, используйте символ `~` перед именем домена. Например: `~example.org##selector`.

Обратите внимание, что вы можете использовать оба подхода в одном правиле. Например, правило `example.org,~subdomain.example.org##domain` будет работать для домена `example.org` и всех его поддоменов, **кроме `subdomain.example.org`**.

> #### Обратите внимание
> Правила скрытия не зависят друг от друга. Если в фильтре есть правило `example.org##selector`, и вы добавляете правило `~example.org##selector`, то оба этих правила будут применены независимо друг от друга.

<a id="elemhide-examples"></a>
#### Примеры правил скрытия

* `example.com##.textad` — скроет элемент `div` с классом `textad` на домене `example.com` и всех его поддоменах.
* `example.com,example.org###adblock` - скроет элемент с атрибутом `id` равным `adblock` на доменах `example.com`, `example.org` и всех их поддоменах.
* `~example.com##.textad` - скроет элемент `div` с классом `textad` на всех доменах, кроме `example.com` и всех его поддоменах.

<a id="elemhide-exceptions"></a>
#### Исключения для правил скрытия

Существует специальный тип правил, "выключающий" отдельные правила скрытия на определенных доменах. Синтаксис таких правил очень похож на обычные правила скрытия, но вместо маркера `##` используется `#@#`.

Например, пусть в фильтре есть следующее правило.
```
##.textad
```

Если вы хотите отключить это правило для домена `example.com`, можно воспользоваться правилом-исключением.
```
example.com#@#.textad
```

Применять такие исключения рекомендуется только в случае, когда изменить само правило скрытия не представляется возможным. Во всех остальных случаях лучше изменить исходное правило, используя ограничение на домены.

> #### Обратите внимание
> Правило-исключение без указания конкретных доменов не имеет смысла и будет проигнорировано.

<a id="cosmetic-css-rules"></a>
### Правила CSS стилей

Иногда недостаточно просто скрыть какой-либо элемент, чтобы заблокировать рекламу. Например, блокировка рекламного элемента может просто сломать верстку сайта. Для таких случаев Adguard позволяет использовать гораздо более гибкие правила, чем обычные правила скрытия. По сути, с помощью таких правил вы можете добавить на страницу любой CSS стиль.

<a id="cosmetic-css-rules-syntax"></a>
#### Синтаксис правил CSS стилей

```
   rule = [domains] "#$#" selector "{" style "}"
domains = [domain0, domain1[, ...[, domainN]]]
```

* **`selector`** — [CSS селектор](https://developer.mozilla.org/ru/docs/Web/Guide/CSS/Getting_Started/Selectors), задающий элементы, которые должны быть скрыты.
* **`domains`** — ограничение на домены, на страницах которых будет применено правило. Строится по тем же правилам, что и в случае [правил скрытия элементов](#elemhide-syntax).
* **`style`** — CSS стиль, который мы хотим применить к элементам, выбранным `selector`.

<a id="cosmetic-css-rules-examples"></a>
#### Примеры правил CSS стилей

```
example.com#$#body { background-color: #333!important; }
```

Это правило применит стиль `background-color: #333!important;` к элементу `body` для домена `example.com` и всех его поддоменов.

<a id="cosmetic-css-rules-exceptions"></a>
#### Исключения для правил CSS стилей

По аналогии с правилами скрытия, существует специальный тип правил, отключающий действие выбранного правила CSS стилей для определенных доменов. Синтаксис правил-исключений практически такой же, только маркер `#$#` заменяется на `#@$#`.

Например, пусть в фильтре есть следующее правило.
```
#$#.textad { visibility: hidden; }
```

Если вы хотите отключить это правило для домена `example.com`, можно воспользоваться правилом-исключением.
```
example.com#@$#.textad { visibility: hidden; }
```

Применять такие исключения рекомендуется только в случае, когда изменить само правило CSS стиля не представляется возможным. Во всех остальных случаях лучше изменить исходное правило, используя ограничение на домены.

<a id="extended-css-selectors"></a>
### Расширенные CSS селекторы

Возможностей CSS 3.0 не всегда хватает для блокировки рекламы. Чтобы решить эту проблему, Adguard расширяет возможности CSS, добавляя поддержку новых псевдо-элементов. Для поддержки расширенных CSS селекторов нами был разработан отдельный модуль [с открытым кодом](https://github.com/AdguardTeam/ExtendedCss).

> #### Обратная совместимость
> В общедоступных фильтрах мы используем так называемый обратно-совместимый синтаксис. Дело в том, что использование расширенных псевдо-классов может помешать применению косметических правил в старых версиях Adguard или других блокировщиках рекламы, не поддерживающих расширенный CSS. Например, вместо псевдо-класса `:has(selector)` можно использовать атрибут `[-ext-has="selector"]`.

> #### Область применения
> Расширенные селекторы можно применять в любом косметическом правиле, будь то [правила скрытия](#cosmetic-elemhide-rules) или [правила CSS стилей](#cosmetic-css-rules).

<a id="extended-css-has"></a>
#### Псевдо-класс `:has()`

Спецификация CSS 4.0 описывает [псевдо-элемент `:has`](https://drafts.csswg.org/selectors/#relational). К сожалению, пока что он не поддерживается браузерами.

##### Синтаксис `:has()`

```
:has(selector)
```

Обратно-совместимый синтаксис:
```
[-ext-has="selector"]
```

Псевдо-класс `:has()` выбирает те элементы, внутри которых есть элементы, подходящие под `selector`.

##### Примеры `:has()`

###### Выбор всех элементов `div`, которые содержат элемент с классом `banner`.

**HTML code**
```html
<div>Do not select this div</div>
<div>Select this div<span class="banner"></span></div>
```

**Селектор**
```css
div:has(.banner)
```

Обратно-совместимый синтаксис:
```css
div[-ext-has=".banner"]
```

<a id="extended-css-contains"></a>
#### Псевдо-класс `:contains()`

Принцип действия этого псевдо-класса очень прост: он позволяет выбрать элементы, которые содержат внутри заданный текст. Обратите внимание, что это должен быть именно текст, а не код. Для проверки используется свойство `innerText`.

##### Синтаксис `:contains()`

```css
:contains(text)
```

Обратно-совместимый синтаксис:
```css
[-ext-contains="text"]
```

Псевдо-класс `:contains()` выбирает те элементы, внутри которых есть текст `text`.

##### Примеры `:contains()`

###### Выбор всех элементов `div`, которые содержат текст `banner`.

**HTML code**
```html
<div>Do not select this div</div>
<div id="selected">Select this div (banner)</div>
<div>Do not select this div <div class="banner"></div></div>
```

**Селектор**
```css
div:contains(banner)
```

Обратно-совместимый синтаксис:
```css
div[-ext-contains="banner"]
```

Обратите внимание, что в этом примере будет выбран только `div` с `id=selected`, так как следующий за ним элемент не содержит текст (`banner` является частью кода, а не текста).

<a id="extended-css-matches-css"></a>
#### Псевдо-класс `:matches-css()`

Этот псевдокласс позволяет выбрать элемент по его текущему свойству стиля.

##### Синтаксис `:matches-css()`

```
/* element style matching */
selector:matches-css(property-name ":" pattern)

/* ::before pseudo-element style matching */
selector:matches-css-before(property-name ":" pattern)

/* ::after pseudo-element style matching */
selector:matches-css-after(property-name ":" pattern)
```

Обратно-совместимый синтаксис:
```
selector[-ext-matches-css="property-name ":" pattern"]
selector[-ext-matches-css-after="property-name ":" pattern"]
selector[-ext-matches-css-before="property-name ":" pattern"]
```

###### `property-name`
Название CSS свойства, которое будет проверено у элемента.

###### `pattern`
Маска значения. Мы используем такой же синтаксис, как и в `pattern`, в базовых правилах.

##### Примеры `:matches-css()`

###### Выбор элементов `div` с псевдо-элементом `::before` с указанным контентом.

**HTML code**
```html
<style type="text/css">
    #to-be-blocked::before {
        content: "Block me"
    }
</style>
<div id="to-be-blocked" class="banner"></div>
<div id="not-to-be-blocked" class="banner"></div>
```

**Селектор**
```css
div.banner:matches-css-before(content: block me)
```

Обратно-совместимый синтаксис:
```css
div.banner[-ext-matches-css-before="content: block me"]
```

<a id="html-filtering-rules"></a>
## Правила фильтрации HTML

В большинстве случаев достаточно использовать базовые и косметические правила. Но иногда для фильтрации рекламы необходимо изменять HTML-код самой страницы до того, как он будет загружен браузером. Для того чтобы сделать это, применяются правила фильтрации HTML-контента. Они позволяют указать, какие HTML-элементы необходимо вырезать из страницы перед тем, как страница попадет в браузер.

> #### Совместимость
> Правила поддерживаются Adguard для Windows, macOS и Android (при установке "способа фильтрации" в режим  "Качественный").
> Для работы правил фильтрации HTML необходима возможность модификации контента на сетевом уровне, поэтому этот тип правил невозможно реализовать в браузерном расширении.

<a id="html-filtering-rules-syntax"></a>
### Синтаксис правил фильтрации HTML

```
      rule = [domains] "$$" tagName [attributes]
   domains = [domain0, domain1[, ...[, domainN]]]      
attributes = "[" name0 = value0 "]" "[" name1 = value2 "]" ... "[" nameN = valueN "]"
```

* **`tagName`** — имя элемента в нижнем регистре, например, `div` или `script`.
* **`domains`** — ограничение на домены, на страницах которых будет применено правило. Строится по тем же правилам, что и в случае [правил скрытия элементов](#elemhide-syntax).
* **`attributes`** — список атрибутов, ограничивающих выбор элементов. `name` - название атрибута, `value` - подстрока, которая содержится в значении атрибута.

<a id="html-filtering-rules-examples"></a>
### Примеры правил фильтрации HTML

**HTML code**
```html
<script data-src="/banner.js"></script>
```

**Правило**
```
example.org$$script[data-src="banner"]
```

Это правило удалит из кода страниц все элементы `script` со значением `data-src`, содержащим подстроку `banner`. При этом правило будет работать только для домена `example.org` и всех его поддоменов.

<a id="html-filtering-rules-attributes"></a>
### Специальные атрибуты

Помимо обычных атрибутов, значение которых проверяется у каждого элемента, существует набор специальных атрибутов правила, которые изменяют способ работы правила. Ниже мы перечислим все эти атрибуты.

<a id="tag-content-attribute"></a>
##### `tag-content`

Пожалуй, наиболее часто используемый специальный атрибут. Он ограничивает выбор теми элементами, внутренний HTML код которых (innerHTML) содержит указанную подстроку.

Например, рассмотрим такой HTML код:
```html
<script type="text/javascript">
    document.write('<div>banner text</div>" />');
</script>
```

Следующее правило удалит со страницы все элементы `script`, код которых содержит подстроку `banner`.
```
$$script[tag-content="banner"]
```

> #### Вложенные элементы
> Если мы имеем дело с несколькими вложенными друг в друга элементами, каждый из которых подходит под одно и то же правило фильтрации HTML-контента, то удалены будут все эти элементы.

<a id="wildcard-attribute"></a>
##### `wildcard`

Этот специальный атрибут работает практически также как `tag-content` и позволяет проверить внутренний HTML-код элемента. Правило проверит, удовлетворяет ли HTML-код элемента заданному [шаблону поиска](https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0).

Возьмем для примера следующее правило:
`$$script[wildcard="*banner*text*"]`

Оно проверит, что код элемента содержит две последовательные подстроки `banner` и `text`.

<a id="max-length-attribute"></a>
##### `max-length`

Задает максимальную длину содержимого HTML-элемента. Если этот параметр задан, и длина содержимого превышает заданное значение — правило не применяется к элементу.

> #### Значение по умолчанию
> Если этот параметр не задан, то `max-length` считается равным 8192.

Например, возьмем следующее правило:
```
$$div[tag-content="banner"][max-length="400"]
```

Это правило удалит все элементы `div`, код которых содержит подстроку `banner`, и длина которых не превышает `400` символов.

<a id="min-length-attribute"></a>
##### `min-length`

Задает минимальную длину содержимого HTML-элемента. Если этот параметр задан, и длина содержимого меньше заданного значения — правило не применяется к элементу.

Например, возьмем следующее правило:
```
$$div[tag-content="banner"][min-length="400"]
```

Это правило удалит все элементы `div`, код которых содержит подстроку `banner`, и длина которых превышает `400` символов.

<a id="parent-elements-attribute"></a>
##### `parent-elements`

Этот атрибут сильно изменяет поведение правила. Обычное правило фильтрации HTML с помощью указанных атрибутов находит и удаляет элемент страницы. В случае, если задан атрибут `parent-elements`, то удален будет не тот элемент, который был найден, а его родительский элемент с именем, заданным атрибутом `parent-elements`.

Рассмотрим пример.

**HTML code**
```html
<table style="background: url('http://domain.com/banner.gif')">
    <tr>
        <td>
            <a href="http://example.org/ads">TEXT ADS</a>
        </td>
    </tr>
</table>
```

Проблема этого HTML-кода в том, что нам недостаточно вырезать ссылку на рекламу. Сам баннер показывается с помощью родительской таблицы (как ее `background`).  Тут нам и приходит на помощь атрибут `parent-elements`. 

Мы используем вот такое правило, чтобы заблокировать всю таблицу: 
```
$$a[href="example.org/ads"][parent-elements="table"]
```

Когда Adguard найдет на странице элемент `a` с атрибутом `href`, содержащим `example.org/ads`, то вместо того, чтобы вырезать его, он будет искать ближайший родительский элемент `table`, и если найдет — вырежет его.

Вы можете указать несколько искомых родительских элементов через запятую. Заблокирован будет ближайший.

<a id="parent-search-level-attribute"></a>
##### `parent-search-level`

Задает максимальную глубину поиска родительского элемента. По умолчанию максимальная глубина поиска равна `3`. 
Это сделано для того чтобы не вырезать лишнего, если HTML-код страницы поменяется. Не используйте слишком большие значения для этого атрибута.

<a id="html-filtering-rules-exceptions"></a>
### Исключения для правил фильтрации HTML

По аналогии с правилами скрытия, существует специальный тип правил, отключающий действие выбранного правила фильтрации HTML для определенных доменов. Синтаксис правил-исключений такой же, только маркер `$$` заменяется на `$@$`.

Например, пусть в фильтре есть следующее правило.
```
$$script[tag-content="banner"]
```

Если вы хотите отключить это правило для домена `example.com`, можно воспользоваться правилом-исключением.
```
example.com$@$script[tag-content="banner"]
```

<a id="javascript-rules"></a>
## Javascript правила

Adguard поддерживает специальный тип правил, позволяющий вставить любой javascript-код на страницы интернет-сайтов.

> #### Ограничения
> Обратите внимание, что этот тип правил может быть использован **только в доверенных фильтрах**. В эту категорию попадает ваш собственный **пользовательский фильтр**, и фильтры, которые создаются командой Adguard.

<a id="javascript-rules-syntax"></a>
### Синтаксис javascript правил

```
rule = [domains]  "#%#" script
```

* **`domains`** — ограничение на домены, на страницах которых будет применено правило. Строится по тем же правилам, что и в случае [правил скрытия элементов](#elemhide-syntax).
* **`script`** — произвольный javascript-код **в одну строку**.

<a id="javascript-rules-examples"></a>
### Примеры javascript правил

* `example.org#%#window.__gaq = undefined;` — выполняет код `window.__gaq = undefined;` на всех страницах сайта `example.org` и всех его поддоменах.

<a id="javascript-rules-exceptions"></a>
### Исключения для javascript правил

По аналогии с правилами скрытия, существует специальный тип правил, отключающий действие выбранного javascript правила для определенных доменов. Синтаксис правил-исключения такой же, только маркер `#%#` заменяется на `#@%#`.

Например, пусть в фильтре есть следующее правило.
```
#%#window.__gaq = undefined;
```

Если вы хотите отключить это правило для домена `example.com`, можно воспользоваться правилом-исключением.
```
example.com#@%#window.__gaq = undefined;
```

<a id="good-luck"></a>
## Удачи в составлении своих фильтров!

Желаем вам удачи в составлении собственных фильтров.

Если вы хотите спросить совета о том, как правильно составлять фильтры, на нашем форуме есть [специальный раздел](https://forum.adguard.com/index.php?forums/25/), посвященный написанию собственных правил.
